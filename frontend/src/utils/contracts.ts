import { ethers } from 'ethers';

// Contract ABIs
// In a real app, these would be imported from JSON files generated by compilation
const ABIS = {
  CryptoRightsToken: [
    // Common ERC721 functions
    'function balanceOf(address owner) view returns (uint256)',
    'function ownerOf(uint256 tokenId) view returns (address)',
    'function transferFrom(address from, address to, uint256 tokenId)',
    'function approve(address to, uint256 tokenId)',
    'function getApproved(uint256 tokenId) view returns (address)',
    'function isApprovedForAll(address owner, address operator) view returns (bool)',
    'function setApprovalForAll(address operator, bool approved)',
    'function tokenURI(uint256 tokenId) view returns (string)',
    
    // Our custom functions
    'function createRight(string memory tokenURI, string memory rightsType, uint256 royaltyBasisPoints) returns (uint256)',
    'function getCreator(uint256 tokenId) view returns (address)',
    'function getRightsType(uint256 tokenId) view returns (string)',
    'function getCreationDate(uint256 tokenId) view returns (uint256)',
    'function getRoyaltyInfo(uint256 tokenId, uint256 salePrice) view returns (address, uint256)',
    'function tokensOfOwner(address owner) view returns (uint256[])',
    
    // Events
    'event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)',
    'event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)',
    'event ApprovalForAll(address indexed owner, address indexed operator, bool approved)',
    'event RightCreated(uint256 indexed tokenId, address indexed creator, string uri, string rightsType, uint256 royaltyBasisPoints)'
  ],
  CryptoRightsMarketplace: [
    // Marketplace functions
    'function listToken(uint256 tokenId, uint256 price)',
    'function buyToken(uint256 tokenId) payable',
    'function cancelListing(uint256 tokenId)',
    'function getListingPrice(uint256 tokenId) view returns (uint256)',
    'function isTokenListed(uint256 tokenId) view returns (bool)',
    'function getListedTokens() view returns (uint256[])',
    
    // Events
    'event TokenListed(uint256 indexed tokenId, address indexed seller, uint256 price)',
    'event TokenSold(uint256 indexed tokenId, address indexed seller, address indexed buyer, uint256 price)',
    'event ListingCancelled(uint256 indexed tokenId, address indexed seller)'
  ]
};

// Contract addresses (Hardhat development)
// In a production app, these would change based on the network
export const CONTRACT_ADDRESSES: Record<string, string> = {
  CryptoRightsToken: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
  CryptoRightsMarketplace: '0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512'
};

/**
 * Get a contract instance with a signer (for write operations)
 * @param contractName The name of the contract to get
 * @param provider The ethers provider
 * @returns A contract instance with signer
 */
export const getContractWithSigner = (contractName: keyof typeof ABIS, provider: any) => {
  if (!provider) {
    throw new Error('Provider is required');
  }
  
  const signer = provider.getSigner();
  return new ethers.Contract(
    CONTRACT_ADDRESSES[contractName],
    ABIS[contractName],
    signer
  );
};

/**
 * Get a contract instance for read-only operations
 * @param contractName The name of the contract to get
 * @param provider The ethers provider
 * @returns A contract instance for read operations
 */
export const getContract = (contractName: keyof typeof ABIS, provider: any) => {
  if (!provider) {
    throw new Error('Provider is required');
  }
  
  return new ethers.Contract(
    CONTRACT_ADDRESSES[contractName],
    ABIS[contractName],
    provider
  );
};

/**
 * Format an address for display
 * @param address The address to format
 * @returns A shortened version of the address
 */
export const formatAddress = (address: string): string => {
  if (!address) return '';
  return `${address.slice(0, 6)}...${address.slice(-4)}`;
};

/**
 * Format Wei to Ether
 * @param wei The amount in wei
 * @returns The amount in ether
 */
export const weiToEther = (wei: string | number | bigint): string => {
  return ethers.utils.formatEther(wei.toString());
};

/**
 * Format Ether to Wei
 * @param ether The amount in ether
 * @returns The amount in wei as a BigNumber
 */
export const etherToWei = (ether: string): ethers.BigNumber => {
  return ethers.utils.parseEther(ether);
}; 